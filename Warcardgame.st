ImageMorph subclass: #Card	instanceVariableNames: 'value suit'	classVariableNames: ''	poolDictionaries: ''	category: 'Maman15'!!Card methodsFor: 'getters' stamp: 'yam 1/23/2023 00:30'!suit	^suit! !!Card methodsFor: 'getters' stamp: 'yam 1/23/2023 00:23'!value	^value! !!Card methodsFor: 'initialization' stamp: 'yam 1/23/2023 08:06'!initializeWithValue: aValue andSuit: aSuit	| cardPictureName |	super initialize.	value := aValue.	suit := aSuit.	cardPictureName := aValue asString,'of',aSuit,'s','.png'.	self image: (ImageReadWriter formFromFileNamed: cardPictureName).! !Object subclass: #CardDeck	instanceVariableNames: 'cards'	classVariableNames: ''	poolDictionaries: ''	category: 'Maman15'!!CardDeck methodsFor: 'as yet unclassified' stamp: 'yam 1/23/2023 01:34'!addCard: aCard	cards add: aCard.! !!CardDeck methodsFor: 'as yet unclassified' stamp: 'yam 1/23/2023 01:28'!cards	^cards! !!CardDeck methodsFor: 'as yet unclassified' stamp: 'yam 1/23/2023 01:28'!initialize	cards := OrderedCollection new.! !!CardDeck methodsFor: 'as yet unclassified' stamp: 'yam 1/23/2023 07:46'!numberOfCards	^(cards size)! !!CardDeck methodsFor: 'as yet unclassified' stamp: 'yam 1/25/2023 04:30'!removeCard	| card |	card := cards atRandom.	cards remove:card.	^card.! !!CardDeck methodsFor: 'as yet unclassified' stamp: 'yam 1/23/2023 01:33'!shuffle	cards := cards shuffle.! !!CardDeck methodsFor: 'as yet unclassified' stamp: 'yam 1/24/2023 03:20'!takeCardsFromDeck: aCardDeck	[aCardDeck numberOfCards ~= 0] whileTrue: [		self addCard: (aCardDeck removeCard)	].! !BorderedMorph subclass: #GamePlayer	instanceVariableNames: 'cardDeck openCards playerName'	classVariableNames: ''	poolDictionaries: ''	category: 'Maman15'!!GamePlayer methodsFor: 'as yet unclassified' stamp: 'yam 1/23/2023 07:59'!cardDeck	^cardDeck	! !!GamePlayer methodsFor: 'as yet unclassified' stamp: 'yam 1/26/2023 01:10'!drawCards: anAmount andPlayerNumber: aNumber	| highestValue index playerNumber drawnCards|		playerNumber := aNumber.	highestValue := 0.	index := 0.	self removeAllMorphs.	(anAmount =0 )	ifTrue:[		openCards at: 1 put: ( (Card new) initializeWithValue: 0 andSuit:'nothing').		openCards at: 2 put: ( (Card new) initializeWithValue: 0 andSuit:'nothing').		openCards at: 3 put: ( (Card new) initializeWithValue: 0 andSuit:'nothing').		self addMorph:(self showCards).		self addMorph:(self showDeckSizeForPlayerNumber: playerNumber).	].	(anAmount = 1)	ifTrue:[		openCards at: 1 put: ( (Card new) initializeWithValue: 0 andSuit:'nothing').		openCards at: 2 put: ( cardDeck removeCard).		openCards at: 3 put: ( (Card new) initializeWithValue: 0 andSuit:'nothing').		self addMorph:(self showCards).		self addMorph:(self showDeckSizeForPlayerNumber: playerNumber).		^(openCards at:2).	].	(anAmount = 3)	ifTrue:[		drawnCards := CardDeck new.		(cardDeck numberOfCards >= 4)		ifTrue:[			drawnCards addCard: cardDeck removeCard.			drawnCards addCard: cardDeck removeCard.			drawnCards addCard: cardDeck removeCard.			openCards at: 1 put: ( (Card new) initializeWithValue: 0 andSuit:'cardback').			openCards at: 2 put: ( (Card new) initializeWithValue: 0 andSuit:'cardback').			openCards at: 3 put: ( (Card new) initializeWithValue: 0 andSuit:'cardback').		]		ifFalse:[			(cardDeck numberOfCards = 3)			ifTrue:[				drawnCards addCard: cardDeck removeCard.				drawnCards addCard: cardDeck removeCard.				openCards at: 1 put: ( (Card new) initializeWithValue: 0 andSuit:'cardback').				openCards at: 2 put: ( (Card new) initializeWithValue: 0 andSuit:'cardback').				openCards at: 3 put: ( (Card new) initializeWithValue: 0 andSuit:'nothing').			].			(cardDeck numberOfCards = 2)			ifTrue:[				drawnCards addCard: cardDeck removeCard.				openCards at: 1 put: ( (Card new) initializeWithValue: 0 andSuit:'nothing').				openCards at: 2 put: ( (Card new) initializeWithValue: 0 andSuit:'cardback').				openCards at: 3 put: ( (Card new) initializeWithValue: 0 andSuit:'nothing').			].			(cardDeck numberOfCards = 1)			ifTrue:[				" Out of cards to draw for war , draw the last one to participate in the war"			].			(cardDeck numberOfCards = 0)			ifTrue:[				" Out of cards, do nothing and wait for war to end"			].		].		self addMorph:(self showCards).		self addMorph:(self showDeckSizeForPlayerNumber: playerNumber).		^(drawnCards).	].						! !!GamePlayer methodsFor: 'as yet unclassified' stamp: 'yam 1/23/2023 19:47'!initializeWithDeck: aCardDeck andPlayerNumber: aNumber	| sampleCard playerNumber |		super initialize.	cardDeck := aCardDeck.	playerNumber := aNumber.	openCards := Array new:3.	(1 to: 3) do: [:i |	      openCards at: i put: ( (Card new) initializeWithValue: 0 andSuit:'nothing').		].	sampleCard := (Card new) initializeWithValue:0 andSuit:'nothing'.	self extent: (4*sampleCard width)@(1.5*sampleCard height).	self layoutPolicy: TableLayout new.	self listDirection: #topToBottom.	self listCentering: #topLeft.	self wrapCentering: #center.	self hResizing: #spaceFill.	self vResizing: #spaceFill.	(aNumber = 1)	ifTrue: [		self color: Color blue.		playerName := 'blue'.	].	(aNumber = 2)	ifTrue: [		self color: Color red.		playerName := 'red'.	].	(aNumber = 3)	ifTrue: [		self color: Color green.		playerName := 'green'.	].	(aNumber = 4)	ifTrue: [		self color: Color yellow.		playerName := 'yellow'.	].	self borderWidth: 3.	self borderColor: Color black.	self addMorph:(self showCards).	self addMorph:(self showDeckSizeForPlayerNumber: playerNumber).	! !!GamePlayer methodsFor: 'as yet unclassified' stamp: 'yam 1/24/2023 00:44'!openCards	^openCards	! !!GamePlayer methodsFor: 'as yet unclassified' stamp: 'yam 1/26/2023 03:28'!playerName	^playerName	! !!GamePlayer methodsFor: 'as yet unclassified' stamp: 'yam 1/25/2023 01:04'!showCards	| sampleCard rowOfCardsMorph |		sampleCard := (Card new) initializeWithValue:0 andSuit:'nothing'.	rowOfCardsMorph := Morph new layoutPolicy: TableLayout new.	rowOfCardsMorph listDirection: #rightToLeft.	rowOfCardsMorph extent: 3*sampleCard width@sampleCard height.	rowOfCardsMorph listCentering: #topLeft.	rowOfCardsMorph wrapCentering: #center.	rowOfCardsMorph addMorph: (openCards at: 1).	rowOfCardsMorph addMorph: (openCards at: 2).	rowOfCardsMorph addMorph: (openCards at: 3).		^rowOfCardsMorph	! !!GamePlayer methodsFor: 'as yet unclassified' stamp: 'yam 1/23/2023 08:04'!showDeckSizeForPlayerNumber: aNumber	| deckSizeMorph sampleCard playerNumber |		playerNumber := aNumber.							sampleCard := (Card new) initializeWithValue:0 andSuit:'nothing'.	deckSizeMorph := TextMorph new contents:(' Cards in deck:',(cardDeck numberOfCards) asString).	deckSizeMorph extent: (3*sampleCard width)@sampleCard height.	deckSizeMorph wrapFlag:true.	deckSizeMorph wrapCentering: #center.	deckSizeMorph color: Color black.		(aNumber = 1)	ifTrue: [		deckSizeMorph backgroundColor: Color blue.		].	(aNumber = 2)	ifTrue: [		deckSizeMorph backgroundColor: Color red.		].	(aNumber = 3)	ifTrue: [		deckSizeMorph backgroundColor: Color green.		].	(aNumber = 4)	ifTrue: [		deckSizeMorph backgroundColor: Color yellow.		].	^deckSizeMorph	! !!GamePlayer methodsFor: 'as yet unclassified' stamp: 'yam 1/26/2023 06:58'!showRoundWinForPlayer: aNumber 	| playerNumber sampleCard roundWinnerMorph |	self removeAllMorphs.	playerNumber := aNumber.							sampleCard := (Card new) initializeWithValue:0 andSuit:'nothing'.	roundWinnerMorph := TextMorph new contents:('Round Winner').	roundWinnerMorph extent: (3*sampleCard width)@sampleCard height.	roundWinnerMorph wrapFlag:true.	roundWinnerMorph wrapCentering: #center.	roundWinnerMorph color: Color black.		(aNumber = 1)	ifTrue: [		roundWinnerMorph backgroundColor: Color blue.		].	(aNumber = 2)	ifTrue: [		roundWinnerMorph backgroundColor: Color red.		].	(aNumber = 3)	ifTrue: [		roundWinnerMorph backgroundColor: Color green.		].	(aNumber = 4)	ifTrue: [		roundWinnerMorph backgroundColor: Color yellow.		].	self addMorph:(self showCards).	self addMorph:(roundWinnerMorph).		! !BorderedMorph subclass: #WarCardGame	instanceVariableNames: 'players'	classVariableNames: ''	poolDictionaries: ''	category: 'Maman15'!!WarCardGame methodsFor: 'as yet unclassified' stamp: 'yam 1/26/2023 07:12'!announceWinner: aNumber	|  result |	UIManager default inform: 'The winner is player color:' , (players at:aNumber) playerName.	result := (PopUpMenu labelArray: #('Yes' 'No')) startUpWithCaption: 'Would you like to play again?'.	(result = 1)	ifTrue:[		(WarCardGame new) playGame.	].	! !!WarCardGame methodsFor: 'as yet unclassified' stamp: 'yam 1/26/2023 01:40'!checkForWar	|  cardValuesArray playersAtWar  |		cardValuesArray := Array new:(players size).	playersAtWar := Set new.	(1 to: players size) do: [:i|		cardValuesArray at:i put: (((players at:i) openCards at:2) value).	].	(1 to: (players size)) do: [:i|		((i+1) to: players size) do: [:j|			( ((cardValuesArray at:i) = (cardValuesArray at:j)) and: ((cardValuesArray at:i)~=0) and: ((cardValuesArray at:j)~=0) )			ifTrue:[				playersAtWar addIfNotPresent: i.				playersAtWar addIfNotPresent: j.				].		].		].	^playersAtWar.		! !!WarCardGame methodsFor: 'as yet unclassified' stamp: 'yam 1/26/2023 03:14'!checkForWinner	| winnerIndex |		winnerIndex := 0.	(1 to: players size) do: [:i|		((((players at:i) cardDeck) numberOfCards) = 52) 		ifTrue:[			winnerIndex := i.		].	].	^winnerIndex.! !!WarCardGame methodsFor: 'as yet unclassified' stamp: 'yam 1/26/2023 07:38'!initialize	|  samplePlayer numberOfPlayers playingDeck cardsPerPlayer playerDeck|	super initialize.	numberOfPlayers := (PopUpMenu labelArray: #('2' '3' '4')) startUpWithCaption: 'Please choose how many players are going to play.'.	numberOfPlayers := numberOfPlayers+1.	samplePlayer := GamePlayer new initializeWithDeck:(CardDeck new initialize) andPlayerNumber:0.	self position: 100@100.	self extent: (samplePlayer width)*numberOfPlayers@samplePlayer height.	self layoutPolicy:TableLayout new.	self listCentering: #topLeft.	self listDirection: #rightToLeft.	self wrapCentering: #center.	self borderWidth: 0.	self color: Color gray.		players := Array new: numberOfPlayers.	cardsPerPlayer := (52/ numberOfPlayers) floor.	playingDeck := CardDeck new initialize.	(2 to: 14) do: [ :i |			playingDeck addCard: (Card new initializeWithValue:i andSuit:'heart').			playingDeck addCard: (Card new initializeWithValue:i andSuit:'club').			playingDeck addCard: (Card new initializeWithValue:i andSuit:'diamond').			playingDeck addCard: (Card new initializeWithValue:i andSuit:'spade').		].	playingDeck shuffle.	(1 to: numberOfPlayers) do: [ :i |		playerDeck := CardDeck new initialize.		(1 to: cardsPerPlayer) do: [:j |			playerDeck addCard:( playingDeck removeCard).			].		players at: i put:(GamePlayer new initializeWithDeck:playerDeck andPlayerNumber:i).		].	(numberOfPlayers = 3)	ifTrue: [		(players at:1) cardDeck addCard: (playingDeck removeCard).		(players at:1) drawCards:0 andPlayerNumber:1.		].		(1 to: numberOfPlayers) do: [ :i |		self addMorph: (players at: i).	].	self openInWorld.				! !!WarCardGame methodsFor: 'as yet unclassified' stamp: 'yam 1/26/2023 03:29'!playGame	| winnerFound winnerIndex |		winnerFound := false.	[winnerFound = false] whileTrue: [		self playRound.		winnerIndex := self checkForWinner.		(winnerIndex ~= 0)		ifTrue:[			winnerFound := true.		].	].		self announceWinner:winnerIndex.		! !!WarCardGame methodsFor: 'as yet unclassified' stamp: 'yam 1/26/2023 07:00'!playRound	| rewardDeck drawnCard highestValue winnerIndex playersAtWar warStatus drawnCardsDeck|		playersAtWar := Set new.	winnerIndex := 0.	highestValue := 0.	rewardDeck := CardDeck new.	warStatus := false.	(Delay forSeconds:0.5) wait.	World doOneCycle.	(1 to: players size) do: [:i|		((((players at:i) cardDeck) numberOfCards) ~= 0) 		ifTrue:[			drawnCard := (players at:i) drawCards:1 andPlayerNumber:i.			rewardDeck addCard:drawnCard.				(Delay forSeconds:0.5) wait.			World doOneCycle.		].	].	playersAtWar := self checkForWar.	(playersAtWar size ~= 0)	ifTrue:[		warStatus := true.		].	(warStatus = false)	ifTrue:[		(Delay forSeconds: 0.5) wait.		(1 to: players size) do: [:i|			( (((players at:i) openCards at:2) value) > highestValue)			ifTrue:[				highestValue := (((players at:i) openCards at:2) value).				winnerIndex := i. 			].			]. 		(players at:winnerIndex) cardDeck takeCardsFromDeck:rewardDeck.		(players at:winnerIndex) showRoundWinForPlayer:winnerIndex.	]	ifFalse:[		[warStatus = true] whileTrue: [			(1 to: players size) do: [:i|				drawnCardsDeck := CardDeck new.					(playersAtWar includes:i)				ifTrue:[						drawnCardsDeck := ((players at:i) drawCards:3 andPlayerNumber:i).							rewardDeck takeCardsFromDeck: drawnCardsDeck.					(Delay forSeconds: 0.5) wait.					World doOneCycle.				].			].			(1 to: players size) do: [:i|				(playersAtWar includes:i)				ifTrue:[					((((players at:i) cardDeck) numberOfCards) ~= 0) 					ifTrue: [						drawnCard := (players at:i) drawCards:1 andPlayerNumber:i.						rewardDeck addCard:drawnCard.							(Delay forSeconds: 0.5) wait.						World doOneCycle.					].				].				].			playersAtWar := Set new.			playersAtWar := self checkForWar.			(playersAtWar size = 0)			ifTrue:[				warStatus := false.				highestValue := 0.				winnerIndex := 0.				(1 to: players size) do: [:i|					( (((players at:i) openCards at:2) value) > highestValue)					ifTrue:[						highestValue := (((players at:i) openCards at:2) value).						winnerIndex := i. 					].					].				(players at:winnerIndex) cardDeck takeCardsFromDeck:rewardDeck.				(players at:winnerIndex) showRoundWinForPlayer:winnerIndex.				World doOneCycle.				(Delay forSeconds: 1) wait.			].		].	].	(Delay forSeconds: 0.5) wait.	World doOneCycle.	(1 to: players size) do: [:i|		(players at:i) drawCards:0 andPlayerNumber:i.	].! !